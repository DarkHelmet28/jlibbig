package jlibbig.bigmc.lang;

import java.util.ArrayList;
import java.io.*;
import beaver.*;
import jlibbig.bigmc.*;
import java.util.*;
import jlibbig.core.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.grammar".
 */
public class BigMCParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short VARID = 1;
		static public final short INNERPLACE = 2;
		static public final short PAROPEN = 3;
		static public final short NIL = 4;
		static public final short SEMICOLON = 5;
		static public final short PIPE = 6;
		static public final short OUTERNAME = 7;
		static public final short SQCLOSE = 8;
		static public final short DPIPE = 9;
		static public final short UNLINKED = 10;
		static public final short CTRL = 11;
		static public final short NUM = 12;
		static public final short COLON = 13;
		static public final short SQOPEN = 14;
		static public final short REACT = 15;
		static public final short POINT = 16;
		static public final short PARCLOSE = 17;
		static public final short COMMA = 18;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9o5bCbFL44GXtzl7iWi30ECi#3CWE8Ehg0YDmyUl6Z2mNZouC631pKnCQuOuX9tO#BDVqz" +
		"nmLrnLzglsnwcVJZw9bzNrQ#hA$Lwkf#aXwfeI1qgQxcMQPDM4AKqO1wPByfgM6krHdMqBW" +
		"qo5hKvq5SvVPtJmofna3DYSumnFnCvdMREp5c5qIebyqCvgx5sm##rBK$zgggcWj9gKEsv#" +
		"gYMqSR5#V$PWg#GLu#je6xy8ZGqgffvQhwfOPwP9rfllfhFzB6WNgtM5gtKkBPgcxPhJ3iq" +
		"ePtQfTreHTinVLUeEk2YEj6Wf8ZTYtbBgtMvCQjS6$tFAiaS#oHpEjavgsIy8jwdGA#jjIq" +
		"lSjabR8PgQVxPB4eXcF#tBVaATgMjqC3FGiQhmalpwtETza0$#nhHJOvzxYQhvYhatMxRFP" +
		"YSSQd4ShsFmGYCmruu28TypWHCmGaVNuHpS0gchURrVN0PhiC1s0ytu2GSzZb7u0nSWgDUc" +
		"mbg78FJthy0n#6yZs$17RW2r#0kNFLp3#0ct8RxSAzPa$F#2jFhyuQRUf9cZmbjJo8U3MDg" +
		"pmV#Wi#9WlpiNshc4t6zNKz#$cmRVThRIIrvp7Spw#oBHMNMF5wIzGxUcjUCx#6DsocPbtm" +
		"7hFqGP7uqdm9$tdRD7Kj1n5tWAuKjSLQh#5NyCXbbuZhdiuPVmrRSVOe3KX1vOkvI1qISRa" +
		"74MRV4xlHRXdu1dNYYam==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};
		
		private Set<String> _outerNames;	//set of %outer
		private BigraphSystem _brs;
		

		/* Parse a string, creating a BRS and a set of Bigraphs from it.
		 * It use an extension of BigMC Language. 
		 * @param str
		 * 		string, in extended-BigMC syntax.
		 * @return BigraphParser.ExtendedBRS
		 *		class that contains a signature, a set of bigraphs and a map containing all reaction rules.
		 */
		public BigraphSystem parse( String str ) throws IOException, Parser.Exception{
			_outerNames = new HashSet<>();		
			_brs = new BigraphSystem();

			BigMCLexer input = new BigMCLexer( new StringReader( str ) );
			parse(input);

			return _brs;
		}

		private void addName( String v ){
			_outerNames.add( v );
			_brs.addName( v );
		}

		private class ParsedBigraph{
			
			private BigraphBuilder bigraph;
			private Map<String , OuterName> outersNames;
			private List<Integer> sitesNames;

			ParsedBigraph( Signature sig ){
				bigraph = new BigraphBuilder( sig );
				outersNames = new HashMap<>();
				sitesNames = new ArrayList<>();
			}
			
			//Note:	this method doesn't return a Milner's Ion (for bigraphs). It will add to the current bigraph one root with a node.
			//	This node have a site inside and, differently from Milner's definition of Ion, it can be linked to inner names.
			public void makeIon( String c , List<String> list ){
				if( bigraph.getSignature().getByName( c ) == null )
					throw new IllegalArgumentException( "Control \"" + c +"\" should be in the signature" );
				
				Node node = bigraph.addNode( c , bigraph.addRoot() );
				bigraph.addSite( node );

				if( list == null ) return;

				List<? extends Port> ports = node.getPorts();

				if( ports.size() < list.size() )
					throw new IllegalArgumentException( "Too many ports indicated ( " + list.size() + " ): control \"" + c +"\" has " + ports.size() + " port(s)" );

				Iterator<? extends Port> portIt = ports.iterator();
				for( String name : list ){
					if( name != null ){
						OuterName outer = outersNames.get( name );
						if( outer == null )
							outersNames.put( name , outer = bigraph.addOuterName() );
						bigraph.relink( (Point) portIt.next() , outer );
					}else
						portIt.next();
				}
			}

			/* Compose two ParsedBigraph. 
			 * @param pb
			 * 		ParsedBigraph to be innerComposed
			 */
			public void compose( ParsedBigraph pb ){
				//preconditions: this.getRoots().size() == 1
				if( pb.bigraph.getRoots().size() != 1 )
					throw new RuntimeException( "The juxtaposition (||) can only appear at the top level" );
				
				BigraphBuilder outer_juxt = new BigraphBuilder( bigraph.getSignature() );
				BigraphBuilder outer_comp = new BigraphBuilder( bigraph.getSignature() );
								
				for( Map.Entry<String , OuterName> o : pb.outersNames.entrySet() ){
					outer_juxt.addInnerName( o.getValue().getName() , outer_juxt.addOuterName( o.getValue().getName() ) );
					if( this.outersNames.containsKey( o.getKey() ) ){
						OuterName outer = outer_comp.addOuterName();
						outer_comp.addInnerName( o.getValue().getName() , outer );
						outer_comp.addInnerName( this.outersNames.put( o.getKey() , outer ).getName() , outer );
					}else
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() ){
					if( !pb.outersNames.containsKey( o.getKey() ) )
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				outer_comp.addSite( outer_comp.addRoot() );
				
				this.bigraph.leftJuxtapose( outer_juxt.makeBigraph() , true );
				this.bigraph.innerCompose( pb.bigraph.makeBigraph() , true );
				this.bigraph.outerCompose( outer_comp.makeBigraph() , true );

				this.sitesNames.addAll( pb.sitesNames );

			}

			/* Juxtapose two ParsedBigraph. 
			 * @param pb
			 */
			public void juxtapose( ParsedBigraph pb ){

				if( !Collections.disjoint( this.sitesNames , pb.sitesNames ) )
					throw new RuntimeException( "The same site ($num) can't appear multiple time in a single bigraph" );
				
				BigraphBuilder outer_comp = new BigraphBuilder( bigraph.getSignature() );
				
				for( Map.Entry<String , OuterName> o : pb.outersNames.entrySet() ){
					if( this.outersNames.containsKey( o.getKey() ) ){
						OuterName outer = outer_comp.addOuterName();
						outer_comp.addInnerName( o.getValue().getName() , outer );
						outer_comp.addInnerName( this.outersNames.put( o.getKey() , outer).getName() , outer );
					}else{
						OuterName out = outer_comp.addOuterName( o.getValue().getName() );
						outer_comp.addInnerName( o.getValue().getName() , out );
						this.outersNames.put( o.getKey() , out );
					}
				}
				
				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() ){
					if( !pb.outersNames.containsKey( o.getKey() ) )
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				this.bigraph.leftJuxtapose( pb.bigraph.makeBigraph() );

 				for( int i = 0 ; i < this.bigraph.getRoots().size() ; ++i )
					outer_comp.addSite( outer_comp.addRoot() );
				this.bigraph.outerCompose( outer_comp.makeBigraph() );

				this.sitesNames.addAll( pb.sitesNames );
			}

			/* Make a Bigraph out of a ParsedBigraph. 
			 * Edges must be managed before calling BigraphBuilder::makeBigraph()
			 *
			 * @return Bigraph
			 */
			public Bigraph switchToBigraph(){
				BigraphBuilder outer_comp = new BigraphBuilder( this.bigraph.getSignature() );
				BigraphBuilder inner_comp = new BigraphBuilder( this.bigraph.getSignature() );
				
				int max = 0;
				for( Integer i : sitesNames )
					if( max  < i ) max = i;

				Root[] arr = new Root[max+1];

				for( int i = 0; i <= max ; ++i )
					arr[i] = null;

				for( Integer i : sitesNames )
					arr[i] = inner_comp.addRoot();

				for( int i = 0; i <= max ; ++i ){
					if( arr[i] != null )
						inner_comp.addSite( arr[i] );
				}

				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() ){
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getKey() ) );
				}
				
				for( int i = 0; i < this.bigraph.getRoots().size() ; ++i )
					outer_comp.addSite( outer_comp.addRoot() );

				this.bigraph.innerCompose( inner_comp.makeBigraph() );
				this.bigraph.outerCompose( outer_comp.makeBigraph() );

				return this.bigraph.makeBigraph();
			}

			/* Close all sites of a ParsedBigraph 
			 */
			public void groundPlaceGraph(){
				BigraphBuilder ground = new BigraphBuilder( this.bigraph.getSignature() );
				for( int i = 0; i < this.bigraph.getSites().size() ; ++i )
					ground.addRoot();
				this.bigraph.innerCompose( ground.makeBigraph() );
			}

			public void addSite( int n ){
				if( sitesNames.contains( n ) )
					throw new IllegalArgumentException( "The same site ($" + n + ") can't appear multiple time in a single bigraph" );
				this.bigraph.addSite( this.bigraph.addRoot() );
				sitesNames.add( n );
			}

			public Set<String> getNames(){
				return outersNames.keySet();
			}
				
		}

	private final Action[] actions;

	public BigMCParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN2,	// [0] start = definitionlist names; returns 'names' although none is marked
			Action.RETURN,	// [1] start = names
			RETURN2,	// [2] names = name names; returns 'names' although none is marked
			Action.RETURN,	// [3] names = reactions
			new Action() {	// [4] name = OUTERNAME VARID.v SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 2];
					final String v = (String) _symbol_v.value;
					 addName( v ); return new Symbol( null );
				}
			},
			RETURN2,	// [5] reactions = reaction reactions; returns 'reactions' although none is marked
			Action.RETURN,	// [6] reactions = models
			Action.NONE,  	// [7] models = 
			new Action() {	// [8] models = t.b SEMICOLON models
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final ParsedBigraph b = (ParsedBigraph) _symbol_b.value;
					
					if( b.bigraph.getSites().size() != 0)
						throw new RuntimeException("Sites ($num) can only appear in reaction rules");
					if( !_outerNames.containsAll( b.getNames() ) )
						throw new RuntimeException("Free names can only appear in reaction rules");
					_brs.addBigraph( b.switchToBigraph() ); return new Symbol( null );
				}
			},
			new Action() {	// [9] definitionlist = CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final Boolean b = (Boolean) _symbol_b.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_sb = _symbols[offset + 6];
					final SignatureBuilder sb = (SignatureBuilder) _symbol_sb.value;
					
				sb.put( v , b , n ); _brs.setSignature( sb.makeSignature() );
				return new Symbol( null );
				}
			},
			new Action() {	// [10] definitions = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Symbol( new SignatureBuilder() );
				}
			},
			new Action() {	// [11] definitions = CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final Boolean b = (Boolean) _symbol_b.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_sb = _symbols[offset + 6];
					final SignatureBuilder sb = (SignatureBuilder) _symbol_sb.value;
					 sb.put( v , b , n ); return new Symbol( sb );
				}
			},
			new Action() {	// [12] reaction = t.b1 REACT t.b2 SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b1 = _symbols[offset + 1];
					final ParsedBigraph b1 = (ParsedBigraph) _symbol_b1.value;
					final Symbol _symbol_b2 = _symbols[offset + 3];
					final ParsedBigraph b2 = (ParsedBigraph) _symbol_b2.value;
					 
						if( !b1.sitesNames.containsAll( b2.sitesNames ) )
							throw new RuntimeException("Every site ($num) of a reactum must appear in its redex");
						
						_brs.addReaction( b1.switchToBigraph() , b2.switchToBigraph() ); 
						return new Symbol( null );
				}
			},
			new Action() {	// [13] t = k.b1 POINT t.b2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b1 = _symbols[offset + 1];
					final ParsedBigraph b1 = (ParsedBigraph) _symbol_b1.value;
					final Symbol _symbol_b2 = _symbols[offset + 3];
					final ParsedBigraph b2 = (ParsedBigraph) _symbol_b2.value;
					 b1.compose( b2 ); return new Symbol( b1 );
				}
			},
			new Action() {	// [14] t = t.b1 PIPE t.b2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b1 = _symbols[offset + 1];
					final ParsedBigraph b1 = (ParsedBigraph) _symbol_b1.value;
					final Symbol _symbol_b2 = _symbols[offset + 3];
					final ParsedBigraph b2 = (ParsedBigraph) _symbol_b2.value;
					 b1.juxtapose( b2 ); b1.bigraph.merge(); return new Symbol( b1 );
				}
			},
			new Action() {	// [15] t = t.b1 DPIPE t.b2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b1 = _symbols[offset + 1];
					final ParsedBigraph b1 = (ParsedBigraph) _symbol_b1.value;
					final Symbol _symbol_b2 = _symbols[offset + 3];
					final ParsedBigraph b2 = (ParsedBigraph) _symbol_b2.value;
					 b1.juxtapose( b2 ); return new Symbol( b1 );
				}
			},
			new Action() {	// [16] t = INNERPLACE NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final Integer n = (Integer) _symbol_n.value;
					 ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.addSite( n ); return new Symbol( b );
				}
			},
			new Action() {	// [17] t = k.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final ParsedBigraph b = (ParsedBigraph) _symbol_b.value;
					 b.groundPlaceGraph(); return new Symbol( b );
				}
			},
			new Action() {	// [18] t = NIL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.bigraph.addRoot(); return new Symbol( b );
				}
			},
			new Action() {	// [19] t = PAROPEN t.b PARCLOSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final ParsedBigraph b = (ParsedBigraph) _symbol_b.value;
					 return new Symbol( b );
				}
			},
			new Action() {	// [20] k = VARID.v SQOPEN nms.l SQCLOSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final LinkedList<String> l = (LinkedList<String>) _symbol_l.value;
					 ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.makeIon( v , l ); return new Symbol( b );
				}
			},
			new Action() {	// [21] k = VARID.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					 ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.makeIon( v , null ); return new Symbol( b );
				}
			},
			new Action() {	// [22] nms = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Symbol( null );
				}
			},
			new Action() {	// [23] nms = nameli.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final LinkedList<String> l = (LinkedList<String>) _symbol_l.value;
					 return new Symbol( l );
				}
			},
			new Action() {	// [24] nameli = name.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					 
					List<String> list = new LinkedList<>(); 
					list.add( v ); return new Symbol( list );
				}
			},
			new Action() {	// [25] nameli = name.v COMMA nameli.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final LinkedList<String> l = (LinkedList<String>) _symbol_l.value;
					 l.addFirst( v ); return new Symbol( l );
				}
			},
			new Action() {	// [26] name = VARID.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					 return new Symbol( v );
				}
			},
			new Action() {	// [27] name = UNLINKED
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Symbol( null );
				}
			}
		};

 	
		_outerNames = new HashSet<>();
		_brs = new BigraphSystem();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
