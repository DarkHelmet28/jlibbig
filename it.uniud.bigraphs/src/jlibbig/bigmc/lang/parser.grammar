%package "jlibbig.bigmc.lang";

%import "java.util.*";
%import "java.io.*";
%import "jlibbig.core.*";
%import "jlibbig.bigmc.*";

%class "BigMCParser";

%embed	{:		
		private BigraphSystem _brs;

		/** 
		 * Parse a string, creating a BRS and a set of Bigraphs from it. Everything will be stored in a BigraphSystem.
		 * @param str 
		 *		String that will be parsed, in BigMC syntax.
		 * @return A system that contains signature, set of bigraphs and a set of reaction rules.
		 * @see BigraphSystem
		 */
		BigraphSystem parse( String str ) throws IOException, Parser.Exception{
			return parse(new StringReader( str ));
		}
		
		/** 
		 * Parse a string, creating a BRS and a set of Bigraphs from it. Everything will be stored in a BigraphSystem.
		 * @param in 
		 *		Reader that will be parsed, in BigMC syntax.
		 * @return A system that contains signature, set of bigraphs and a set of reaction rules.
		 * @see BigraphSystem
		 */
		BigraphSystem parse(Reader in) throws IOException, Parser.Exception{	
			_brs = null;
			parse(new BigMCLexer(in));
			return _brs;
		}

		/** 
		 * Parse a string, creating a BRS and a set of Bigraphs from it. Everything will be stored in a BigraphSystem.
		 * @param str 
		 *		String that will be parsed, in BigMC syntax.
		 * @param sig
		 *		Signature that will be used by the BigraphSystem. Controls defined in the parsed string must agree with the signature's controls.
		 * @return A system that contains signature, set of bigraphs and a set of reaction rules.
		 * @see BigraphSystem
		 */
		BigraphSystem parse(String str , Signature sig) throws IOException, Parser.Exception {
			return parse(new StringReader(str) , sig);
		}
	
		/** 
		 * Parse a string, creating a BRS and a set of Bigraphs from it. Everything will be stored in a BigraphSystem.
		 * @param in 
		 *		Reader that will be parsed, in BigMC syntax.
		 * @param sig
		 *		Signature that will be used by the BigraphSystem. Controls defined in the parsed string must agree with the signature's controls.
		 * @return A system that contains signature, set of bigraphs and a set of reaction rules.
		 * @see BigraphSystem
		 */
		BigraphSystem parse(Reader in , Signature sig) throws IOException, Parser.Exception {
			_brs = new BigraphSystem( sig );
			parse(new BigMCLexer(in));
			return _brs;
		}

	:};

%init	{: 	
		_brs = null;
	:};

%terminals CTRL, OUTERNAME, SEMICOLON, COLON, NIL, NUM, VARID, POINT, PIPE, DPIPE, UNLINKED, COMMA, SQOPEN, SQCLOSE, PAROPEN, PARCLOSE, INNERPLACE, REACT;

%typeof VARID , name  = "String";
%typeof NUM = "Integer";
%typeof CTRL = "Boolean";
%typeof big = "ReactionBigraphBuilder";

%typeof definitions = "SignatureBuilder";

%typeof nms , nameli = "LinkedList<String>";

%left POINT;
%left PIPE;
%left DPIPE;

%goal start;

start	= definitionlist models	
	| models		
	;

names	= names OUTERNAME VARID.v SEMICOLON	{: _brs.addName( v ); return new Symbol( null ); :}
	| {: if( _brs == null ) _brs = new BigraphSystem( new SignatureBuilder().makeSignature() ); return new Symbol( null ); :}		
	;


models	= models big.b SEMICOLON
		{:
			for( OuterName out : b.getOuterNames() ){
				if( !_brs.getOuterNames().contains( out.getName() ) )
					throw new RuntimeException( "Agents' outernames can't be free names. Eachone of them must be declared (using %outer or %name). Undeclared name: " + out.getName() );
			} 
			try{
				_brs.addBigraph( new AgentBigraph( b.makeBigraph() ) );
			}catch( IllegalArgumentException e ){ 
				throw new RuntimeException( "Sites can only appear in reaction rules." );
			}
			return new Symbol( null );
		:}
	| models big.b1 REACT big.b2 SEMICOLON
		{:
			_brs.addReaction( b1.makeReactionBigraph() , b2.makeReactionBigraph() );
			return new Symbol( null );
		:}
	| names
	;

definitionlist = definitions.sb CTRL.b VARID.v COLON NUM.n SEMICOLON 
			{:
				if( _brs == null ){
					sb.put( v , b , n ); 
					_brs = new BigraphSystem( sb.makeSignature() );
				}else{
					Control c = null;
				if( (c = _brs.getSignature().getByName( v )) == null || c.getArity() != n || c.isActive() != b )
					throw new RuntimeException( "Control " + v + ", " + (b == true ? "active" : "passive") + " and with arity " + n + ", not found in the input's signature" );
				}
				return new Symbol( null ); 
			:}
	;

definitions = {: return new Symbol( new SignatureBuilder() ); :}
	| definitions.sb CTRL.b VARID.v COLON NUM.n SEMICOLON 	
		{: 	
			if( _brs == null ){
				if( sb.contains( v ) )
					throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_b.getStart() ) + " - Control already defined: " + v );
				sb.put( v , b , n ); 
				return new Symbol( sb );
			}
			Control c = null;
			if( (c = _brs.getSignature().getByName( v )) == null || c.getArity() != n || c.isActive() != b )
				throw new RuntimeException( "Control " + v + ", " + (b == true ? "active" : "passive") + " and with arity " + n + ", not found in the input's signature" );
			return new Symbol( null );
		:}
	;

big	= VARID.v			
		{: 
			ReactionBigraphBuilder rbb = new ReactionBigraphBuilder( _brs.getSignature() ); 
			rbb.addNode( v , rbb.addRoot() );
			return new Symbol( rbb );
		:}
	| VARID.v SQOPEN nms.l SQCLOSE	
		{: 
			ReactionBigraphBuilder rbb = new ReactionBigraphBuilder( _brs.getSignature() );
			rbb.addNode( v , rbb.addRoot() , rbb.addOuterNames( l ) );
			return new Symbol( rbb );
		:}
	| VARID.v POINT big.b		
		{:
			if( b.getRoots().size() != 1 )
				throw new RuntimeException( "Juxtaposition (||) can only appear at top level." );
			b.outerAddNode( v );
			return new Symbol( b );
		:}
	| VARID.v SQOPEN nms.l SQCLOSE POINT big.b
		{:
			if( b.getRoots().size() != 1 )
				throw new RuntimeException( "Juxtaposition (||) can only appear at top level." );
			b.outerAddNode( v , b.addOuterNames( l ) );
			return new Symbol( b );
		:}
	| big.b1 PIPE big.b2		
		{:
			if( b1.getRoots().size() != 1 || b2.getRoots().size() != 1 )
				throw new RuntimeException( "Juxtaposition (||) can only appear at top level." );
			b1.rightParallelProduct( b2.makeReactionBigraph() );
			b1.merge();
			return new Symbol( b1 );
		:}
	| big.b1 DPIPE big.b2		
		{: 
			b1.rightParallelProduct( b2.makeReactionBigraph() );
			return new Symbol( b1 );
		 :}
	| INNERPLACE NUM.n		
		{: 
			ReactionBigraphBuilder rbb = new ReactionBigraphBuilder( _brs.getSignature() ); 
			rbb.addSite( rbb.addRoot() , n );
			return new Symbol( rbb ); 
		:}
	| NIL	
		{: 
			ReactionBigraphBuilder rbb = new ReactionBigraphBuilder( _brs.getSignature() ); 
			rbb.addRoot();
			return new Symbol( rbb ); 
		:}
	| PAROPEN big.b PARCLOSE	{: return new Symbol( b ); :}
	;

nms	= 			{: return new Symbol( new LinkedList<>() ); :}
	| nameli.l		{: return new Symbol( l ); :}
	;

nameli	= name.v		{: 
					List<String> list = new LinkedList<>(); 
					list.add( v ); return new Symbol( list ); 
				:}
	| name.v COMMA nameli.l	{: l.addFirst( v ); return new Symbol( l ); :}
	;

name	= VARID.v		{: return new Symbol( v ); :}
	| UNLINKED		{: return new Symbol( null ); :}
	;
