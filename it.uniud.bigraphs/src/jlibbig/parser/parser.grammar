%package "jlibbig";

%import "java.util.*";
%import "java.io.*";

%class "BigraphParser";

%embed	{:		
		private Signature _sig;
		private Set<String> _outerNames;	//insieme %outer
		private Set<String> _innerNames;	//insieme %inner
		
		public void parse( String str ) throws IOException, Parser.Exception{
			_outerNames = new HashSet<>();
			_innerNames = new HashSet<>();			
			
			BigraphLexer input = new BigraphLexer( new StringReader( str ) );
			parse(input);

			//return value deve essere un BRS + set bigrafi
		}

		public class Name<K,V>{
				private final K name;
				private final V type;

				public Name( K name , V type ){
					this.name = name;
					this.type = type;
				}
				public K getName(){ return name; }
				public V getType(){ return type; }
		}
	
	:};

%init	{: 	
		_outerNames = new HashSet<>();
		_innerNames = new HashSet<>();
	:};

%terminals CTRL, OUTERNAME, INNERNAME, SEMICOLON, COLON, NIL, NUM, VARID, POINT, PIPE, DPIPE, UNLINKED, COMMA, SQOPEN, SQCLOSE, PAROPEN, PARCLOSE, INNERPLACE, REACT, INNER, OUTER, EDGE, LINKED;

%typeof VARID  = "String";
%typeof NUM = "Integer";
%typeof CTRL = "Boolean";

%typeof definitions = "SignatureBuilder";

%typeof nms , nameli = "LinkedList<Name<String , Character>>";
%typeof name = "Name<String , Character>";


%left POINT;
%left PIPE;
%left DPIPE;

%goal start;

start	= definitionlist names	
	| names			
	;

names	= namedef names		
	| reactions		
	;

reactions = reaction reactions		//inserisce reazioni nelle strutture del parser
	| models		
	;

models	= 				//converte in bigrafi, inserisce bigrafi nelle strutture del parser , return new Symbol( null );
	| model SEMICOLON models		
	;

definitionlist = CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb 
			{:
				sb.put( v , b , n ); _sig = sb.makeSignature();
				System.out.println( _sig.toString() );
				return new Symbol( null ); 
			:}
	;

definitions = {: return new Symbol( new SignatureBuilder() ); :}
	| CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb	{: sb.put( v , b , n ); return new Symbol( sb ); :}
	;

namedef	= OUTERNAME VARID.v SEMICOLON {: _outerNames.add( v ); return new Symbol( null ); :}
	| INNERNAME VARID.v SEMICOLON {: _innerNames.add( v ); return new Symbol( null ); :}
	;

reaction = model REACT model SEMICOLON				//converte in bigrafi , torna coppia redex reactum
	;

model	= t.b							//deve tornare un bigraphBuilder
	| links.l
	| links.l DPIPE model.b
	;

links 	= LINKED nms.l		//{: addLinks( null , l ); :}	//deve tornare un bigraphBuilder
	| name.n LINKED nms.l	//{: addLinks( n , l ); :}	//l puo' essere anche NULL
	;

t	= k.b1 POINT t.b2		//controllo no inner names e inner places con nome uguale
	| t.b1 PIPE t.b2		//si merge roots
	| t.b1 DPIPE t.b2		//no merge roots
	| INNERPLACE NUM.n
	| k.b
	| NIL
	| PAROPEN t.b PARCLOSE
	;

k	= node SQOPEN nms.l SQCLOSE	//l.size() porte , controllo no inner names con nome uguale
	| node				//tutte le porte vuote
	;

node	= VARID.v			// v appartiene a _sig
	| VARID.v1 COLON VARID.v2	// v1 nome per nodo di tipo v2 ( v2 appartiene a _sig )
	;


nms	= 			{: return new Symbol( null ); :}
	| nameli.l		{: return new Symbol( l ); :}
	;

nameli	= name.s		{: List<Name<String , Character>> list = new LinkedList<>(); list.add( s ); return new Symbol( list ); :}
	| name.s COMMA nameli.l	{: l.addFirst( s ); return new Symbol( l ); :}
	;

name	= VARID.v INNER {: return new Symbol( new Name<String , Character>( v , 'i' ) ); :}
	| VARID.v OUTER	{: return new Symbol( new Name<String , Character>( v , 'o' ) ); :}
	| VARID.v EDGE	{: return new Symbol( new Name<String , Character>( v , 'e' ) ); :}
	| VARID.v	{: return new Symbol( new Name<String , Character>( v , _outerNames.contains( v ) ? 'o' : 
										_innerNames.contains( v ) ? 'i' : 'e' ) ); 
			:}
	| UNLINKED	{: return new Symbol( null ); :}
	;

