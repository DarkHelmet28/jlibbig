%package "jlibbig.udlang";

%import "java.util.*";
%import "java.io.*";
%import "jlibbig.core.*";

%class "BigraphParser";

%embed	{:		
		private Set<String> _outerNames;	//set of %outer
		private Set<String> _innerNames;	//set of %outer
		private ExtendedBRS _brs;
		

		/* Parse a string, creating a BRS and a set of Bigraphs from it.
		 * It use an extension of BigMC Language. 
		 * @param str
		 * 		string, in extended-BigMC syntax.
		 * @return BigraphParser.ExtendedBRS
		 *		class that contains a signature, a set of bigraphs and a map containing all reaction rules.
		 */
		public ExtendedBRS parse( String str ) throws IOException, Parser.Exception{
			_outerNames = new HashSet<>();
			_innerNames = new HashSet<>();			
			_brs = new ExtendedBRS();

			BigraphLexer input = new BigraphLexer( new StringReader( str ) );
			parse(input);

			return _brs;
		}

		private class ParsedBigraph extends BigraphBuilder{
			
			private Map<String , OuterName> edgesNames;
			private Map<String , OuterName> outersNames;
			private Set<String> innersNames;
			private Set<Integer> sitesNames;

			ParsedBigraph( Signature sig ){
				super( sig );
				edgesNames = new HashMap<>();
				outersNames = new HashMap<>();
				innersNames = new HashSet<>();
				sitesNames = new HashSet<>();
			}
			
			//Note:	this method doesn't return a Milner's Ion (for bigraphs). It will add to the current bigraph one root with a node.
			//	This node have a site inside and, differently from Milner's definition of Ion, it can be linked to inner names.
			public void makeIon( String c , List<Name<String , Character>> list ){
				if( getSignature().getByName( c ) == null )
					throw new IllegalArgumentException( "Control " + c +" should be in the signature." );
				
				Node node = addNode( c , addRoot() );
				addSite( node );

				if( list == null ) return;

				List<? extends Port> ports = node.getPorts();

				if( ports.size() < list.size() )
					throw new IllegalArgumentException( "Control " + c +" have " + ports.size() + " ports, " + list.size() + " ports were found." );

				Iterator<? extends Port> portIt = ports.iterator();
				for( Name<String , Character> name : list ){
					switch ( name.getType() ){
           					case 'i':
							if( innersNames.contains( name.getName() ) )
								throw new RuntimeException( "Innernames (" + name.getName() + ") can't appear multiple time in a single bigraph." );
							Handle inner_edge = ((Port) portIt.next()).getHandle();
							addInnerName( name.getName() , inner_edge );
							innersNames.add( name.getName() ); 
                     					break;
						case 'o':
							OuterName outer = outersNames.get( name.getName() );
							if( outer == null )
								outersNames.put( name.getName() , outer = addOuterName() );
							relink( (Point) portIt.next() , outer );
							break;
						case 'e':
							OuterName edge = edgesNames.get( name.getName() );
							if( edge == null )
								edgesNames.put( name.getName() , edge = addOuterName() );
							relink( (Point) portIt.next() , edge );
							break;
						case 'u':
							portIt.next();
							break;
					}
				}
			}

			/* Compose two ParsedBigraph. 
			 * @param pb
			 * 		ParsedBigraph to be innerComposed
			 */
			public void compose( ParsedBigraph pb ){
				//preconditions: this.getRoots().size() == 1
				if( pb.getRoots().size() != 1 )
					throw new RuntimeException( "The double-parallel operator (||) can only appear at the top level" );
				
				if( !Collections.disjoint( this.innersNames , pb.innersNames ) )
					throw new RuntimeException( "Innernames can't appear multiple time in a single bigraph." );

				BigraphBuilder inner_juxt = new BigraphBuilder( getSignature() );
				BigraphBuilder outer_juxt = new BigraphBuilder( getSignature() );
				BigraphBuilder outer_comp = new BigraphBuilder( getSignature() );

				for( String str : this.innersNames )
					inner_juxt.addInnerName( str , inner_juxt.addOuterName( str ) );
								
				for( Map.Entry<String , OuterName> o : pb.outersNames.entrySet() ){
					outer_juxt.addInnerName( o.getValue().getName() , outer_juxt.addOuterName( o.getValue().getName() ) );
					if( this.outersNames.containsKey( o.getKey() ) ){
						OuterName outer = outer_comp.addOuterName();
						outer_comp.addInnerName( o.getValue().getName() , outer );
						outer_comp.addInnerName( this.outersNames.put( o.getKey() , outer ).getName() , outer );
					}else
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() ){
					if( !pb.outersNames.containsKey( o.getKey() ) )
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				for( Map.Entry<String , OuterName> e : pb.edgesNames.entrySet() ){
					outer_juxt.addInnerName( e.getValue().getName() , outer_juxt.addOuterName( e.getValue().getName() ) );
					if( this.edgesNames.containsKey( e.getKey() ) ){
						OuterName edge = outer_comp.addOuterName();
						outer_comp.addInnerName( e.getValue().getName() , edge );
						outer_comp.addInnerName( this.edgesNames.put( e.getKey() , edge ).getName() , edge );
					}else
						outer_comp.addInnerName( e.getValue().getName() , outer_comp.addOuterName( e.getValue().getName() ) );
				}

				for( Map.Entry<String , OuterName> e : this.edgesNames.entrySet() ){
					if( !pb.edgesNames.containsKey( e.getKey() ) )
						outer_comp.addInnerName( e.getValue().getName() , outer_comp.addOuterName( e.getValue().getName() ) );
				}
				
				outer_comp.addSite( outer_comp.addRoot() );
				
				pb.rightJuxtapose( inner_juxt.makeBigraph() , true );
				this.leftJuxtapose( outer_juxt.makeBigraph() , true );
				this.innerCompose( pb.makeBigraph() , true );
				this.outerCompose( outer_comp.makeBigraph() , true );

				this.innersNames.addAll( pb.innersNames );
				this.sitesNames.addAll( pb.sitesNames );

			}

			/* Juxtapose two ParsedBigraph. 
			 * @param pb
			 */
			public void juxtapose( ParsedBigraph pb ){

				if( !Collections.disjoint( this.sitesNames , pb.sitesNames ) )
					throw new RuntimeException( "The same site ($num) can't appear multiple time in a single bigraph." );

				if( !Collections.disjoint( this.innersNames , pb.innersNames ) )
					throw new RuntimeException( "Innernames can't appear multiple time in a single bigraph." );
				
				BigraphBuilder outer_comp = new BigraphBuilder( getSignature() );
				
				for( Map.Entry<String , OuterName> o : pb.outersNames.entrySet() ){
					if( this.outersNames.containsKey( o.getKey() ) ){
						OuterName outer = outer_comp.addOuterName();
						outer_comp.addInnerName( o.getValue().getName() , outer );
						outer_comp.addInnerName( this.outersNames.put( o.getKey() , outer).getName() , outer );
					}else{
						OuterName out = outer_comp.addOuterName( o.getValue().getName() );
						outer_comp.addInnerName( o.getValue().getName() , out );
						this.outersNames.put( o.getKey() , out );
					}
				}
				
				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() ){
					if( !pb.outersNames.containsKey( o.getKey() ) )
						outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getValue().getName() ) );
				}

				for( Map.Entry<String , OuterName> e : pb.edgesNames.entrySet() ){
					if( this.edgesNames.containsKey( e.getKey() ) ){
						OuterName edge = outer_comp.addOuterName();
						outer_comp.addInnerName( e.getValue().getName() , edge );
						outer_comp.addInnerName( this.edgesNames.put( e.getKey() , edge ).getName() , edge );
					}else{
						OuterName out = outer_comp.addOuterName( e.getValue().getName() );
						outer_comp.addInnerName( e.getValue().getName() , out );
						this.edgesNames.put( e.getKey() , out );
					}
				}

				for( Map.Entry<String , OuterName> e : this.edgesNames.entrySet() ){
					if( !pb.edgesNames.containsKey( e.getKey() ) )
						outer_comp.addInnerName( e.getValue().getName() , outer_comp.addOuterName( e.getValue().getName() ) );
				}

				this.leftJuxtapose( pb.makeBigraph() );

 				for( int i = 0 ; i < this.getRoots().size() ; ++i )
					outer_comp.addSite( outer_comp.addRoot() );
				this.outerCompose( outer_comp.makeBigraph() );

				this.innersNames.addAll( pb.innersNames );
				this.sitesNames.addAll( pb.sitesNames );
			}

			/* Add to the ParsedBigraph relations between outer (or edge) and inner interface
			 * Es: outer <- inner1 , inner2
			 * @param o
			 * 		Handler (outer or edge) used
			 * @param list
			 *		List of inner names linked with the handler o (first parameter)
			 */
			public void addLinks( Name<String , Character> o , LinkedList<Name<String , Character>> list ){

				OuterName out;
				if( list == null && ( o == null || o.getType() == 'e' || o.getType() == 'u' ) ) return;

				if( o == null ){
					out = addOuterName();
					edgesNames.put( out.getName() , out );
				}else{ 
					switch( o.getType() ){
						case 'o':
							out = addOuterName();
							outersNames.put( o.getName() , out );
							break;
						case 'e':
							out = addOuterName();
							edgesNames.put( o.getName() , out );
							break;
						case 'u':
							out = addOuterName();
							edgesNames.put( out.getName() , out );
							break;
						default:
							throw new IllegalArgumentException( "In <- operator, innernames can't appear as a prefix (" + o.getName() + ":i)" );
					}
				}

				for( Name<String , Character> name : list ){
					if( name.getType() != 'i' )
						throw new IllegalArgumentException( "In <- operator, only innernames can appear as a suffix (" + name.getName() + ":" + name.getType() + ")" );
					if( innersNames.contains( name.getName() ) )
						throw new RuntimeException( "Innernames (" + name.getName() + ") can't appear multiple time in a single bigraph." );
					addInnerName( name.getName() , out );
					innersNames.add( name.getName() );
				}	
			}	


			/* Make a Bigraph out of a ParsedBigraph. 
			 * Edges must be managed before calling BigraphBuilder::makeBigraph()
			 *
			 * @return Bigraph
			 */
			public Bigraph switchToBigraph(){
				BigraphBuilder outer_comp = new BigraphBuilder( getSignature() );
				
				for( Map.Entry<String , OuterName> o : this.outersNames.entrySet() )
					outer_comp.addInnerName( o.getValue().getName() , outer_comp.addOuterName( o.getKey() ) );
				for( OuterName o : this.edgesNames.values() )
					outer_comp.addInnerName( o.getName() );
				for( int i = 0; i < this.getRoots().size() ; ++i )
					outer_comp.addSite( outer_comp.addRoot() );

				this.outerCompose( outer_comp.makeBigraph() );

				return this.makeBigraph();
			}

			/* Close all sites of a ParsedBigraph 
			 */
			public void groundPlaceGraph(){
				BigraphBuilder ground = new BigraphBuilder( getSignature() );
				for( int i = 0; i < getSites().size() ; ++i )
					ground.addRoot();
				for( String str : innersNames )
					ground.addInnerName( str , ground.addOuterName( str ) );
				innerCompose( ground.makeBigraph() );
			}

			public void addSite( int n ){
				if( sitesNames.contains( n ) )
					throw new IllegalArgumentException( "The same site ($" + n + ") can't appear multiple time in a single bigraph." );
				addSite( addRoot() );
				sitesNames.add( n );
			}
				
		}

		public class ExtendedBRS{
			private Signature signature;
			private Set<Bigraph> bigraphs;
			private Map<Bigraph , Bigraph> reactionRules;
			
			ExtendedBRS(){
				signature = null;
				bigraphs = new HashSet<>();
				reactionRules = new HashMap<>();
			}
			
			public void setSignature( Signature sig ){ 
				signature = sig; 
			}
			
			public Signature getSignature(){ 
				return signature; 
			}

			public void addBigraph( Bigraph b ){
				bigraphs.add( b );
			}
			
			public void addReaction( Bigraph redex , Bigraph reactum ){
				if(	redex.getRoots().size() != reactum.getRoots().size() || 
					!redex.getOuterNames().containsAll( reactum.getOuterNames() ) ||
					!redex.getInnerNames().containsAll( reactum.getInnerNames() ) )
						throw new RuntimeException("The interface of a reactum must be the same of its redex (both inner and outer faces)");

				reactionRules.put( redex , reactum );
			}
			
			public Set<Bigraph> getBigraphs(){
				return bigraphs;
			}
			
			public Map<Bigraph , Bigraph> getReactions(){
				return reactionRules;
			}
		}

		public class Name<K,V>{
			private final K name;
			private final V type;

			public Name( K name , V type ){
				this.name = name;
				this.type = type;
			}
			public K getName(){ return name; }
			public V getType(){ return type; }
		}
	
	:};

%init	{: 	
		_outerNames = new HashSet<>();
		_innerNames = new HashSet<>();
		_brs = new ExtendedBRS();
	:};

%terminals CTRL, OUTERNAME, INNERNAME, SEMICOLON, COLON, NIL, NUM, VARID, POINT, PIPE, DPIPE, UNLINKED, COMMA, SQOPEN, SQCLOSE, PAROPEN, PARCLOSE, INNERPLACE, REACT, INNER, OUTER, EDGE, LINKED;

%typeof VARID , node  = "String";
%typeof NUM = "Integer";
%typeof CTRL = "Boolean";

%typeof definitions = "SignatureBuilder";

%typeof k , t , links , model = "ParsedBigraph";

%typeof nms , nameli = "LinkedList<Name<String , Character>>";
%typeof name = "Name<String , Character>";


%left POINT;
%left PIPE;
%left DPIPE;

%goal start;

start	= definitionlist names	
	| names			
	;

names	= namedef names		
	| reactions		
	;

reactions = reaction reactions
	| models		
	;

models	= 				
	| model.b SEMICOLON models	{: _brs.addBigraph( b.switchToBigraph() ); return new Symbol( null ); :}
	;

definitionlist = CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb 
			{:
				sb.put( v , b , n ); _brs.setSignature( sb.makeSignature() );
				return new Symbol( null ); 
			:}
	;

definitions = {: return new Symbol( new SignatureBuilder() ); :}
	| CTRL.b VARID.v COLON NUM.n SEMICOLON definitions.sb	{: sb.put( v , b , n ); return new Symbol( sb ); :}
	;

namedef	= OUTERNAME VARID.v SEMICOLON {: _outerNames.add( v ); return new Symbol( null ); :}
	| INNERNAME VARID.v SEMICOLON {: _innerNames.add( v ); return new Symbol( null ); :}
	;

reaction = model.b1 REACT model.b2 SEMICOLON	{: 
							if( !b1.sitesNames.containsAll( b2.sitesNames ) )
								throw new RuntimeException("Sites ($num) in a reactum must be the same of its redex.");
							_brs.addReaction( b1.switchToBigraph() , b2.switchToBigraph() ); return new Symbol( null ); 
						:}
	;

model	= t.b			{: return new Symbol( b ); :}	
	| links.l		{: return new Symbol( l ); :}
	| links.l DPIPE model.b	{: b.juxtapose( l ); return new Symbol( b ); :}
	;

links 	= LINKED nms.l		{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() );  b.addLinks( null , l ); return new Symbol( b ); :}
	| name.n LINKED nms.l	{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.addLinks( n , l ); return new Symbol( b ); :}
	;

t	= k.b1 POINT t.b2		{: b1.compose( b2 ); return new Symbol( b1 ); :}
	| t.b1 PIPE t.b2		{: b1.juxtapose( b2 ); b1.merge(); return new Symbol( b1 ); :}
	| t.b1 DPIPE t.b2		{: b1.juxtapose( b2 ); return new Symbol( b1 ); :}
	| INNERPLACE NUM.n		{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.addSite( n ); return new Symbol( b ); :}
	| k.b				{: b.groundPlaceGraph(); return new Symbol( b ); :}
	| NIL				{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.addRoot(); return new Symbol( b ); :}
	| PAROPEN t.b PARCLOSE		{: return new Symbol( b ); :}
	;

k	= node.c SQOPEN nms.l SQCLOSE	{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.makeIon( c , l ); return new Symbol( b ); :}
	| node.c			{: ParsedBigraph b = new ParsedBigraph( _brs.getSignature() ); b.makeIon( c , null ); return new Symbol( b ); :}
	;

node	= VARID.v			{: return new Symbol( v ); :}
	| VARID.v1 COLON VARID.v2	{: return new Symbol( v2 ); :}	//TODO v1 nome per nodo di tipo v2 ( v2 appartiene a _brs.getSignature() )
	;


nms	= 			{: return new Symbol( null ); :}
	| nameli.l		{: return new Symbol( l ); :}
	;

nameli	= name.s		{: List<Name<String , Character>> list = new LinkedList<>(); list.add( s ); return new Symbol( list ); :}
	| name.s COMMA nameli.l	{: l.addFirst( s ); return new Symbol( l ); :}
	;

name	= VARID.v INNER {: return new Symbol( new Name<String , Character>( v , 'i' ) ); :}
	| VARID.v OUTER	{: return new Symbol( new Name<String , Character>( v , 'o' ) ); :}
	| VARID.v EDGE	{: return new Symbol( new Name<String , Character>( v , 'e' ) ); :}
	| VARID.v	{: return new Symbol( new Name<String , Character>( v , _outerNames.contains( v ) ? 'o' : 
										_innerNames.contains( v ) ? 'i' : 'e' ) ); 
			:}
	| UNLINKED	{: return new Symbol( new Name<String , Character>( null , 'u' ) ); :}
	;

