%package "jlibbig.udlang";

%import "java.util.*";
%import "java.io.*";
%import "jlibbig.core.*";

%class "BRSParser";

//TODO: eliminare error recovery

%embed	{:	
	private static final BRSParser instance = new BRSParser();
	private BigraphReactiveSystem _sys;


	BRSParser getInstance(){
		return instance;
	}

	/**
	 * Generate a system (sets of bigraphs and reactions with the same
	 * signature) from a string.
	 * 
	 * @param str
	 *            the string that will be parsed.
	 * @return Return a system, carrying bigraphs and reactions with the same
	 *         signature.
	 * @throws IOException
	 * @throws Parser.Exception
	 * @see BigraphReactiveSystem
	 */
	BigraphReactiveSystem parse(String str) throws IOException, Exception {
		return parse(new StringReader(str));
	}

	BigraphReactiveSystem parse(Reader in) throws IOException, Exception {
		_sys = null;
		parse(new BRSLexer(in));
		return _sys;
	}

	BigraphReactiveSystem parse(String str , Signature sig) throws IOException, Exception {
		return parse(new StringReader(str) , sig);
	}

	BigraphReactiveSystem parse(Reader in , Signature sig) throws IOException, Exception {
		_sys = new BigraphReactiveSystem( sig );
		parse(new BRSLexer(in));
		return _sys;
	}

	/**
	 * This class stores inner and outer names
	 *
	 */
	private class NameId{
		private String name;
		private Boolean outer;
		NameId( String name , Boolean outer ){
			this.name = name;
			this.outer = outer;
		}	
	}
		
	private class ParsedBigraph{
		private BigraphBuilder bb;
		private Boolean polymorphicSites;
		private List<Integer> siteNames;

		ParsedBigraph( Signature sig ){
			bb = new BigraphBuilder( sig );
			polymorphicSites = false;
			siteNames = new ArrayList<>();			
		}

		void closeSites(){
			this.polymorphicSites = false;
			BigraphBuilder ground = new BigraphBuilder( this.bb.getSignature() );
			for( int i = 0; i < this.bb.getSites().size() ; ++i )
				ground.addRoot();
			for( InnerName in : this.bb.getInnerNames() )
				ground.addInnerName( in.getName() , ground.addOuterName( in.getName() ) );
			this.bb.innerCompose( ground.makeBigraph() );
		}

		void juxtapose( ParsedBigraph pb ) throws IllegalArgumentException{
			if( !Collections.disjoint( this.siteNames , pb.siteNames ) )
				throw new IllegalArgumentException( "Can't juxtapose two bigraph with overlapping sites: " + this.siteNames + " + " + pb.siteNames );
			if( pb.polymorphicSites )
				pb.closeSites();
			if( this.polymorphicSites )
				this.closeSites();

			this.bb.rightJuxtapose( pb.bb.makeBigraph() );
			this.siteNames.addAll( pb.siteNames );
		}

		void parallelProduct( ParsedBigraph pb ) throws IllegalArgumentException{
			if( !Collections.disjoint( this.siteNames , pb.siteNames ) )
				throw new IllegalArgumentException( "Can't juxtapose two bigraph with overlapping sites: " + this.siteNames + " + " + pb.siteNames );
			if( pb.polymorphicSites )
				pb.closeSites();
			if( this.polymorphicSites )
				this.closeSites();

			this.bb.rightParallelProduct( pb.bb.makeBigraph() );
			this.siteNames.addAll( pb.siteNames );
		}

		void merge( ParsedBigraph pb ) throws IllegalArgumentException{
			if( !Collections.disjoint( this.siteNames , pb.siteNames ) )
				throw new IllegalArgumentException( "Can't juxtapose two bigraph with overlapping sites: " + this.siteNames + " + " + pb.siteNames );
			if( pb.polymorphicSites )
				pb.closeSites();
			if( this.polymorphicSites )
				this.closeSites();

			this.bb.rightParallelProduct( pb.bb.makeBigraph() );
			this.bb.merge();
			this.siteNames.addAll( pb.siteNames );
		}

		void outerNest( ParsedBigraph pb ) throws RuntimeException{
			if( pb.polymorphicSites ){
				if( pb.bb.getSites().size() == 0 ){
					for( int i = 0 ; i < this.bb.getRoots().size() ; ++i ){
						pb.bb.addSite( pb.bb.addRoot() );
						pb.siteNames.add( i );
					}
				}else{
					pb.siteNames.add( 0 );
				}
				pb.polymorphicSites = false;
			}

			Set<String> this_outernames = new HashSet<>();
			Set<String> outer_innernames = new HashSet<>();
			Map<String , OuterName> outer_outernames = new HashMap<>(); 

			for( OuterName out : this.bb.getOuterNames() )
				this_outernames.add( out.getName() );

			for( InnerName inn : pb.bb.getInnerNames() ){
				if( !this_outernames.contains( inn.getName() ) ){
					try{
						this.bb.addInnerName( inn.getName() , this.bb.addOuterName( inn.getName() ) );
					}catch( RuntimeException e ){
						throw new RuntimeException( "The same innername ( -" + inn.getName() + " ) can't appear multiple times in a single bigraph" );
					}
				}
				outer_innernames.add( inn.getName() );
			}

			for( OuterName out : pb.bb.getOuterNames() )
				outer_outernames.put( out.getName() , out );

			for( String outer : this_outernames ){
				if( !outer_innernames.contains( outer ) ){
					OuterName outername = outer_outernames.get( outer );
					if( outername == null ){
						OuterName new_out = pb.bb.addOuterName( outer );
						outer_outernames.put( outer , new_out );
						pb.bb.addInnerName( outer , new_out );
					}else
						pb.bb.addInnerName( outer , outername );
				}
			}

			this.bb.outerCompose( pb.makeBigraph() );
		}

		void rename( NameId outer , List<NameId> names ) throws RuntimeException{
			if( outer == null && names.size() == 0 ) return;
			if( outer != null && outer.outer != null && !outer.outer )
				throw new IllegalArgumentException( "Innernames ( -" + outer.name + " ) can't appear as the first argument of <x/xs> operator." );
			BigraphBuilder outer_bigraph = new BigraphBuilder( this.bb.getSignature() );
			
			Handle o = null;
			if( outer != null )
				o = outer_bigraph.addOuterName( outer.name );
			
			Set<String> this_outernames = new HashSet<>();
			Set<String> names_string = new HashSet<>(); 

			for( OuterName out : this.bb.getOuterNames() )
				this_outernames.add( out.getName() );
 
			for( NameId name : names ){
				if( name.outer != null && name.outer )
					throw new RuntimeException("Outernames ( +" + name.name + " ) can't appear in the second argument of <x/xs> operator." );
				String new_name = name.name;
				if( name.outer != null || !this_outernames.contains( name.name ) ){
					OuterName newOuter = this.bb.addOuterName();
					try{
					this.bb.addInnerName( name.name , newOuter );
					}catch( RuntimeException e ){
						throw new RuntimeException("The same innername ( -" + name.name + " ) can't appear multiple times in a single bigraph");
					}
					new_name = newOuter.getName();
				}else
					names_string.add( name.name );

				if( o == null )
					o = outer_bigraph.addInnerName( new_name ).getHandle();
				else
					outer_bigraph.addInnerName( new_name , o );
			}

			for( String outername : this_outernames ){
				if( !names_string.contains( outername ) ){
					if( outer == null || !outer.name.equals( outername ) )
						outer_bigraph.addInnerName( outername , outer_bigraph.addOuterName( outername ));					
					else
						outer_bigraph.addInnerName( outername , o );
				}					
			}

			for( int i = 0; i < this.bb.getRoots().size() ; ++i )
				outer_bigraph.addSite( outer_bigraph.addRoot() );

			this.bb.outerCompose( outer_bigraph.makeBigraph() );				
		}

		Bigraph makeBigraph() throws RuntimeException{
			if( polymorphicSites && bb.getSites().size() == 1 ){
				closeSites();
				return bb.makeBigraph();
			}

			class SiteInt implements Comparable<SiteInt>{
				private Root root;
				private Integer pos;
				SiteInt( Root r , int i ){
					root = r;
					pos = i;
				}
				public int compareTo( SiteInt si ){
					return pos.compareTo( si.pos );
				}
			}

				
			if( bb.getSites().size() != siteNames.size() )
				throw new RuntimeException( "Error while checking the number of sites. Indices Lost." );

			List<SiteInt> siteints = new ArrayList<>();
			BigraphBuilder inner = new BigraphBuilder( bb.getSignature() );
			for( InnerName in : bb.getInnerNames() )
				inner.addInnerName( in.getName() , inner.addOuterName( in.getName() ) );

			for( Integer v : siteNames )
				siteints.add( new SiteInt( inner.addRoot() , v ) );
				
			Collections.sort( siteints );
			for( SiteInt sint : siteints )
				inner.addSite( sint.root );
					
			bb.innerCompose( inner.makeBigraph() );

			return bb.makeBigraph();
		}

	}

	static ParsedBigraph site( Signature sig , Integer i ){
		ParsedBigraph pb = instance.new ParsedBigraph( sig );
		pb.bb.addSite( pb.bb.addRoot() );
		pb.siteNames.add( i );
		return pb;
	}

	static ParsedBigraph nil( Signature sig ){
		ParsedBigraph pb = instance.new ParsedBigraph( sig );
		pb.bb.addRoot();
		return pb;
	}

	static ParsedBigraph node( Signature sig , String name , List<NameId> list ) throws RuntimeException{
		ParsedBigraph pb = instance.new ParsedBigraph( sig );
		pb.polymorphicSites = true;

		if( pb.bb.getSignature().getByName( name ) == null )
			throw new IllegalArgumentException( "Control \"" + name +"\" should be in the signature." );
		//place graph
		Node node = pb.bb.addNode( name , pb.bb.addRoot() );
		pb.bb.addSite( node );

		//link graph
		if( list == null ) return pb;

		List<? extends Port> ports = node.getPorts();

		if( ports.size() < list.size() )
			throw new IllegalArgumentException( "Control \"" + name +"\" have " + ports.size() + " ports, " + list.size() + " ports found in one of its instances." );

		Map<String , OuterName> outerNames = new HashMap<>();
		Set<String> innerNames = new HashSet<>();

		Iterator<? extends Port> portIt = ports.iterator();
		for( NameId nameid : list ){
			if( nameid == null ){ 
				//case: "-" , skip this port (already has an edge attached to it)
				portIt.next();
				continue;
			}
			if( nameid.outer == null || nameid.outer == true ){
				//case: "+p" or "p" , this name must appear in the outerface of this bigraph
				OuterName outer = outerNames.get( nameid.name );
				if( outer == null )
					outerNames.put( nameid.name , outer = pb.bb.addOuterName( nameid.name ) );
				pb.bb.relink( (Point) portIt.next() , outer );	
			}else{
				//case: "-p" , innerface
				if( innerNames.contains( nameid.name ) )
					throw new RuntimeException( "Innernames ( -" + nameid.name + " ) can't appear multiple time in a single bigraph." );
				Handle inner_edge = ((Port) portIt.next()).getHandle();
				pb.bb.addInnerName( nameid.name , inner_edge );
				innerNames.add( nameid.name ); 
			}
		}
				
		return pb;
	}

	static int[] eta( List<Integer> redex_sites , List<Integer> parsed_eta ) throws RuntimeException{
		int[] r_eta = new int[ parsed_eta.size() ];
		int i = 0;
		for( Integer j : parsed_eta ){
			if( ( r_eta[i++] = redex_sites.indexOf( j ) ) == -1 )
				throw new RuntimeException("No sites named " + j + " in the redex of this reaction. Sites: " + redex_sites + ". Eta: " + parsed_eta);
		}
		return r_eta;
	}
:};

%terminals MODE , SEMICOLON , COLON , REACT , NIL , ZERO , ONE , NUM , VARID , POINT , PIPE , DPIPE , DASH , COMMA , PLUS , SQOPEN , SQCLOSE , PAROPEN , PARCLOSE , TAGOPEN , TAGCLOSE , SLASH , SIGIL , PERCENT;

%typeof MODE = "boolean";
%typeof VARID = "String";
%typeof NUM , num = "int";
%typeof definitions = "SignatureBuilder";
%typeof name , voidorname = "NameId";
%typeof names , notemptynames , namesnonull , notemptynamesnonull = "LinkedList<NameId>";
%typeof eta , notemptyeta = "LinkedList<Integer>";

%typeof big = "ParsedBigraph";

%right POINT;
%left SLASH;
%left PIPE;
%left DPIPE;
%left PLUS;

%goal start;

start	= definitionlist models
	| models
	;

definitionlist
	= definitions.sb MODE.m VARID.v COLON num.n SEMICOLON
		{:
			if( _sys == null ){
				if( sb.contains( v ) )
					throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_m.getStart() ) + " - Control already defined: " + v );
				sb.put( v , m , n );
				_sys = new BigraphReactiveSystem( sb.makeSignature() );
				return new Symbol( null );
			}
			Control c = null;
			if( (c = _sys.getSignature().getByName( v ) ) == null || n > c.getArity() || c.isActive() != m )
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_m.getStart() ) + " - Control " + v + ", " + (m == true ? "active" : "passive") + " and with arity greater or equal to " + n + ", not found in the input's signature" );
			return new Symbol( null );
		:}
	;

definitions
	=	{:
			if( _sys == null ) return new Symbol( new SignatureBuilder() );
			return new Symbol( null );
		:}
	| definitions.sb MODE.m VARID.v COLON num.n SEMICOLON
		{:
			if( _sys == null ){
				if( sb.contains( v ) )
					throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_m.getStart() ) + " - Control already defined: " + v );
				sb.put( v , m , n );
				return new Symbol( sb );
			}
			Control c = null;
			if( (c = _sys.getSignature().getByName( v ) ) == null || n > c.getArity() || c.isActive() != m )
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_m.getStart() ) + " - Control " + v + ", " + (m == true ? "active" : "passive") + " and with arity greater or equal to " + n + ", not found in the input's signature" );
			return new Symbol( null );			
		:}
	;

models	= models big.b SEMICOLON
		{: 
			try{
				_sys.addBigraph( b.makeBigraph() );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_b.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( null );
		:}
	| models big.r REACT big.s SEMICOLON
		{: 
			try{
				_sys.addReaction( r.makeBigraph() , s.makeBigraph() , new int[0] );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_s.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( null );
		:}
	| models big.r REACT big.s PERCENT eta.et SEMICOLON
		{:
			ArrayList<Integer> redex_sites = new ArrayList<>( r.siteNames );
			Collections.sort( redex_sites );
			try{
				_sys.addReaction( r.makeBigraph() , s.makeBigraph() , eta( redex_sites , et ) );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_s.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( null );
		:}
	| {: if( _sys == null ) _sys = new BigraphReactiveSystem( new SignatureBuilder().makeSignature() ); return new Symbol( null ); :}
	;

big	= big.b PLUS big.p
		{:
			try{
				b.juxtapose( p );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_p.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );
		:}
	| big.b DPIPE big.p
		{:
			try{
				b.parallelProduct( p );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_p.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );
		:}
	| big.b PIPE big.p
		{:
			try{
				b.merge( p );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_p.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );
		:}	
	| big.p POINT big.b
		{:
			try{
				b.outerNest( p );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_p.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );
		:}
	| TAGOPEN voidorname.x SLASH namesnonull.l TAGCLOSE
		{:
			ParsedBigraph b = new ParsedBigraph( _sys.getSignature() );
			b.polymorphicSites = true;
			try{
				b.rename( x , l );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_x.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );
		:}
	| TAGOPEN voidorname.x SLASH namesnonull.l TAGCLOSE big.b
		{:
			try{
				b.rename( x , l );
			}catch( RuntimeException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_x.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( b );	
		:}
	| VARID.c SQOPEN names.l SQCLOSE
		{: 
			ParsedBigraph pb;
			try{		
				pb = node( _sys.getSignature() , c , l );
			}catch( IllegalArgumentException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_c.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( pb );
		:}
	| VARID.c
		{: 
			ParsedBigraph pb;
			try{		
				pb = node( _sys.getSignature() , c , null );
			}catch( IllegalArgumentException e ){
				throw new RuntimeException( "Line: " + Symbol.getLine( _symbol_c.getStart() ) + " - " + e.getMessage() );
			}
			return new Symbol( pb );
		:}
	| SIGIL num.n
		{: return new Symbol( site( _sys.getSignature() , n ) ); :}
	| ZERO	{: return new Symbol( new ParsedBigraph( _sys.getSignature() ) ); :}
	| ONE	{: return new Symbol( nil( _sys.getSignature() ) ); :}
	| PAROPEN big.pb PARCLOSE
		{: return new Symbol( pb ); :}
	| NIL	{: return new Symbol( nil( _sys.getSignature() ) ); :}
	;

eta	=	{: return new Symbol( new LinkedList<>() ); :}
	| notemptyeta.l {: return new Symbol( l ); :}
	;

notemptyeta	
	= num.n	
		{: 
			LinkedList<Integer> l = new LinkedList<>();
			l.add( n );
			return new Symbol( l );
		:}
	| num.n COMMA notemptyeta.l
		{:
			l.addFirst( n );
			return new Symbol( l );
		:}
	;

num	= ZERO		{: return new Symbol( 0 ); :}
	| ONE		{: return new Symbol( 1 ); :}
	| NUM.n		{: return new Symbol( n ); :}
	;

voidorname
	= 		{: return new Symbol( null ); :}
	| name.n	{: return new Symbol( n ); :}
	;

namesnonull 
	= 	{: return new Symbol( new LinkedList<>() ); :}
	| notemptynamesnonull.l
		{: return new Symbol( l ); :}
	;

notemptynamesnonull	
	= name.n
		{:
			List<NameId> l = new LinkedList<>();
			l.add( n );
			return new Symbol( l );
		:}
	| name.n COMMA notemptynamesnonull.l 	
		{: l.addFirst( n ); return new Symbol( l ); :}
	;

names	= 	{: return new Symbol( new LinkedList<>() ); :}
	| notemptynames.l
		{: return new Symbol( l ); :}
	;

notemptynames	
	= name.n
		{:
			List<NameId> l = new LinkedList<>();
			l.add( n );
			return new Symbol( l );
		:}
	| DASH
		{:
			List<NameId> l = new LinkedList<>();
			l.add( null );
			return new Symbol( l );
		:}
	| name.n COMMA notemptynames.l
		{: l.addFirst( n ); return new Symbol( l ); :}
	| DASH COMMA notemptynames.l
		{: l.addFirst( null ); return new Symbol( l ); :}
	;

name	= PLUS VARID.n	{: return new Symbol( new NameId( n , true ) ); :}
	| VARID.n	{: return new Symbol( new NameId( n , null ) ); :}
	| DASH VARID.n	{: return new Symbol( new NameId( n , false ) ); :}
	;

